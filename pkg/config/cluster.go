package config

import (
	"crypto/x509"
	"fmt"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/dcos/dcos-cli/constants"

	"github.com/spf13/afero"
	"github.com/spf13/cast"
)

type SSLError struct {
	msg error
}

func (e *SSLError) Error() string {
	return e.msg.Error()
}

func NewSSLError(e error) *SSLError {
	return &SSLError{msg: e}
}

// Cluster is a subset representation of a DC/OS CLI configuration.
//
// It is a proxy struct on top of a config which provides user-friendly getters and setters for common
// configurations such as "core.dcos_url" or "core.ssl_verify". It leverages Go types as much as possible.
type Cluster struct {
	config *Config
	id     string
}

// NewCluster returns a new cluster for a given config, if omitted it uses an empty config.
func NewCluster(conf *Config) *Cluster {
	if conf == nil {
		conf = Empty()
	}
	return &Cluster{config: conf}
}

// URL returns the public master URL of the DC/OS cluster.
func (c *Cluster) URL() string {
	url := cast.ToString(c.config.Get("core.dcos_url"))
	return strings.TrimRight(url, "/")
}

// SetURL sets the public master URL of the DC/OS cluster.
func (c *Cluster) SetURL(url string) {
	c.config.Set("core.dcos_url", url)
}

// ACSToken returns the token generated by authenticating
// to DC/OS using the Admin Router Access Control Service.
func (c *Cluster) ACSToken() string {
	return cast.ToString(c.config.Get("core.dcos_acs_token"))
}

// SetACSToken sets the token generated by authenticating
// to DC/OS using the Admin Router Access Control Service.
func (c *Cluster) SetACSToken(acsToken string) {
	c.config.Set("core.dcos_acs_token", acsToken)
}

// SetTLS returns the configuration for TLS clients.
func (c *Cluster) SetTLS(tls TLS) {
	c.config.Set("core.ssl_verify", tls.String())
}

// CheckTLS returns error if provided certificate is invalid
func (c *Cluster) TLS() (TLS, error) {
	tlsVal := cast.ToString(c.config.Get("core.ssl_verify"))

	if tlsVal == "" {
		return TLS{Insecure: false}, nil
	}

	// Try to cast the value to a bool, true means we verify
	// server certificates, false means we skip verification.
	if verify, err := strconv.ParseBool(tlsVal); err == nil {
		return TLS{Insecure: !verify}, nil
	}

	// The value is not a string representing a bool thus it is a path to a root CA bundle.
	rootCAsPEM, err := afero.ReadFile(c.config.Fs(), tlsVal)
	if err != nil {
		return TLS{
			Insecure:    true,
			RootCAsPath: tlsVal,
		}, fmt.Errorf("can't read %s: %s", tlsVal, err)
	}

	// Decode the PEM root certificate(s) into a cert pool.
	certPool := x509.NewCertPool()
	if !certPool.AppendCertsFromPEM(rootCAsPEM) {
		return TLS{
			Insecure:    true,
			RootCAsPath: tlsVal,
		}, fmt.Errorf("cannot decode the PEM root certificate(s) into a cert pool: %s", tlsVal)
	}

	// The cert pool has been successfully created, store it in the TLS config.
	return TLS{
		RootCAs:     certPool,
		RootCAsPath: tlsVal,
	}, nil
}

// Timeout returns the HTTP request timeout once the connection is established.
func (c *Cluster) Timeout() time.Duration {
	timeout := c.config.Get(keyTimeout)
	if timeout == nil {
		return constants.HTTPTimeout
	}
	return time.Duration(cast.ToInt64(timeout)) * time.Second
}

// SetTimeout sets the HTTP request timeout once the connection is established.
func (c *Cluster) SetTimeout(timeout time.Duration) {
	c.config.Set(keyTimeout, timeout.Seconds())
}

// ID returns the ID of the cluster.
func (c *Cluster) ID() string {
	if c.id != "" {
		return c.id
	}
	path := c.Config().Path()
	return filepath.Base(filepath.Dir(path))
}

// SetID sets a custom id for the cluster.
func (c *Cluster) SetID(id string) {
	c.id = id
}

// Name returns the custom name for the cluster.
func (c *Cluster) Name() string {
	return cast.ToString(c.config.Get("cluster.name"))
}

// SetName sets a custom name for the cluster.
func (c *Cluster) SetName(name string) {
	c.config.Set("cluster.name", name)
}

// Config returns the cluster's config.
func (c *Cluster) Config() *Config {
	return c.config
}

// Dir returns the cluster's directory.
func (c *Cluster) Dir() string {
	return filepath.Dir(c.Config().Path())
}

// TLS holds the configuration for TLS clients.
type TLS struct {
	// Insecure specifies if server certificates should be accepted without verification.
	//
	// Skipping verification against the system's CA bundle or a cluster-specific CA is highly discouraged
	// and should only be done during testing/development.
	Insecure bool

	// Path to the root CA bundle.
	RootCAsPath string

	// A pool of root CAs to verify server certificates against.
	RootCAs *x509.CertPool
}

// String creates a string from a TLS struct.
func (tls *TLS) String() string {
	if tls.RootCAsPath != "" {
		return tls.RootCAsPath
	}
	return strconv.FormatBool(!tls.Insecure)
}
