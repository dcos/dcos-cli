package config

import (
	"crypto/x509"
	"io"
	"strings"
	"time"

	toml "github.com/pelletier/go-toml"
)

// Config for the DC/OS CLI.
type Config struct {
	url            string
	acsToken       string
	tls            TLS
	timeout        int
	sshUser        string
	sshProxyHost   string
	pagination     bool
	reporting      bool
	mesosMasterURL string
	promptLogin    bool
	clusterName    string

	store       *Store
	dirtyFields map[interface{}]bool
}

// URL returns the public master URL of the DC/OS cluster.
func (conf *Config) URL() string {
	return conf.url
}

// SetURL sets the public master URL of the DC/OS cluster.
func (conf *Config) SetURL(url string) {
	conf.url = url
	conf.setDirty(&conf.url)
}

// ACSToken returns the token generated by authenticating
// to DC/OS using the Admin Router Access Control Service.
func (conf *Config) ACSToken() string {
	return conf.acsToken
}

// SetACSToken sets the token generated by authenticating
// to DC/OS using the Admin Router Access Control Service.
func (conf *Config) SetACSToken(acsToken string) {
	conf.acsToken = acsToken
	conf.setDirty(&conf.acsToken)
}

// TLS returns the configuration for TLS clients.
func (conf *Config) TLS() TLS {
	return conf.tls
}

// SetTLS returns the configuration for TLS clients.
func (conf *Config) SetTLS(tls TLS) {
	conf.tls = tls
	conf.setDirty(&conf.tls)
}

// Timeout returns the HTTP request timeout in seconds once the connection is established.
func (conf *Config) Timeout() time.Duration {
	return time.Duration(conf.timeout) * time.Second
}

// SetTimeout sets the HTTP request timeout in seconds once the connection is established.
func (conf *Config) SetTimeout(timeout int) {
	conf.timeout = timeout
	conf.setDirty(&conf.timeout)
}

// SSHUser returns the default username for node SSH access.
func (conf *Config) SSHUser() string {
	return conf.sshUser
}

// SetSSHUser sets the default username for node SSH access.
func (conf *Config) SetSSHUser(sshUser string) {
	conf.sshUser = sshUser
	conf.setDirty(&conf.sshUser)
}

// SSHProxyHost returns the SSH proxy host (Bastion) for node SSH access.
func (conf *Config) SSHProxyHost() string {
	return conf.sshProxyHost
}

// SetSSHProxyHost sets the SSH proxy host (Bastion) for node SSH access.
func (conf *Config) SetSSHProxyHost(sshProxyHost string) {
	conf.sshProxyHost = sshProxyHost
	conf.setDirty(&conf.sshProxyHost)
}

// Pagination returns whether to paginate the output of the commands.
func (conf *Config) Pagination() bool {
	return conf.pagination
}

// SetPagination sets whether to paginate the output of the commands.
func (conf *Config) SetPagination(pagination bool) {
	conf.pagination = pagination
	conf.setDirty(&conf.pagination)
}

// Reporting returns whether to report usage events to Mesosphere.
func (conf *Config) Reporting() bool {
	return conf.reporting
}

// SetReporting sets whether to report usage events to Mesosphere.
func (conf *Config) SetReporting(reporting bool) {
	conf.reporting = reporting
	conf.setDirty(&conf.reporting)
}

// MesosMasterURL returns the Mesos master URL. Must be set in format "http://host:port".
func (conf *Config) MesosMasterURL() string {
	return conf.mesosMasterURL
}

// SetMesosMasterURL sets the Mesos master URL. Must be set in format "http://host:port".
func (conf *Config) SetMesosMasterURL(mesosMasterURL string) {
	conf.mesosMasterURL = mesosMasterURL
	conf.setDirty(&conf.mesosMasterURL)
}

// PromptLogin returns whether to automatically prompt the user to log in when their token expired.
func (conf *Config) PromptLogin() bool {
	return conf.promptLogin
}

// SetPromptLogin sets whether to automatically prompt the user to log in when their token expired.
func (conf *Config) SetPromptLogin(promptLogin bool) {
	conf.promptLogin = promptLogin
	conf.setDirty(&conf.promptLogin)
}

// ClusterName returns the custom name for the cluster.
func (conf *Config) ClusterName() string {
	return conf.clusterName
}

// SetClusterName sets a custom name for the cluster.
func (conf *Config) SetClusterName(clusterName string) {
	conf.clusterName = clusterName
	conf.setDirty(&conf.clusterName)
}

// setDirty sets a field as "dirty", this is used by the Marshal
// function to know which fields must be persisted to the Store.
func (conf *Config) setDirty(field interface{}) {
	conf.dirtyFields[field] = true
}

// Store returns the Store associated to the Config.
func (conf *Config) Store() *Store {
	return conf.store
}

// SetPath sets a path for the Config.
func (conf *Config) SetPath(path string) {
	conf.store.path = path
}

// Save unmarshals the Config into its associated Store and persists it to the disk.
func (conf *Config) Save() error {
	Marshal(conf, conf.store)
	return conf.store.Persist()
}

// TLS holds the configuration for TLS clients.
type TLS struct {
	// Insecure specifies if server certificates should be accepted without verification.
	//
	// Skipping verification against the system's CA bundle or a cluster-specific CA is highly discouraged
	// and should only be done during testing/development.
	Insecure bool

	// Path to the root CA bundle.
	RootCAsPath string

	// A pool of root CAs to verify server certificates against.
	RootCAs *x509.CertPool
}

// New instanciates a configuration with all fields set to their zero values.
func New() Config {
	return Config{
		store:       NewStore(StoreOpts{}),
		dirtyFields: make(map[interface{}]bool),
	}
}

// Default returns the default configuration for the DC/OS CLI.
// All config defaults are their zero value except for the timeout which is 180 seconds.
func Default() Config {
	conf := New()
	conf.timeout = 180
	return conf
}

// FromPath creates a Config based on a path to a TOML file.
func FromPath(path string) (Config, error) {
	f, err := fs.Open(path)
	if err != nil {
		return Config{}, err
	}
	defer f.Close()

	conf, err := FromReader(f)
	conf.store.SetPath(path)
	return conf, nil
}

// FromString creates a Config using a string representing the configuration formatted as a TOML document.
func FromString(tomlData string) (Config, error) {
	return FromReader(strings.NewReader(tomlData))
}

// FromReader creates a Config based on an io.Reader.
func FromReader(reader io.Reader) (Config, error) {
	tree, err := toml.LoadReader(reader)
	if err != nil {
		return Config{}, err
	}

	conf := Default()
	Unmarshal(NewStore(StoreOpts{Tree: tree}), &conf)
	return conf, nil
}
