package dcos

import (
	"bytes"
	"crypto/x509"
	"errors"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"

	homedir "github.com/mitchellh/go-homedir"
	toml "github.com/pelletier/go-toml"
	"github.com/spf13/afero"
	"github.com/spf13/cast"
)

// TOML keys for the DC/OS configuration.
const (
	configKeyURL            = "core.dcos_url"
	configKeyACSToken       = "core.dcos_acs_token"
	configKeyTLS            = "core.ssl_verify"
	configKeyTimeout        = "core.timeout"
	configKeySSHUser        = "core.ssh_user"
	configKeySSHProxyHost   = "core.ssh_proxy_ip"
	configKeyPagination     = "core.pagination"
	configKeyReporting      = "core.reporting"
	configKeyMesosMasterURL = "core.mesos_master_url"
	configKeyPromptLogin    = "core.prompt_login"
	configKeyClusterName    = "cluster.name"
	dcosDefaultFolder       = "~/.dcos"
)

// Environment variables for the DC/OS configuration.
const (
	envTLS     = "DCOS_SSL_VERIFY"
	envTimeout = "DCOS_TIMEOUT"
)

var (
	// ErrNoConfigPath indicates that no path is specified for a config.
	ErrNoConfigPath = errors.New("no path specified for the config")

	// ErrNotAttached indicates that no cluster is attached.
	ErrNotAttached = errors.New("no cluster is attached")

	// ErrConfigNotFound means that the manager cannot find a config using a name/id.
	ErrConfigNotFound = errors.New("no match found")

	// ErrTooManyConfigs means that more than one config has been found for a given search.
	ErrTooManyConfigs = errors.New("multiple matches found")
)

// Config is a DC/OS client configuration.
//
// It is a proxy struct on top of a ConfigStore which provides user-friendly getters and setters for common
// configurations such as "core.dcos_url" or "core.ssl_verify". It leverages Go types as much as possible.
type Config struct {
	store *ConfigStore
	id    string
}

// NewConfig returns a new config for a given store, if omitted it uses an empty store.
func NewConfig(store *ConfigStore) *Config {
	if store == nil {
		store = NewConfigStore(nil)
	}
	return &Config{store: store}
}

// URL returns the public master URL of the DC/OS cluster.
func (c *Config) URL() string {
	url := cast.ToString(c.store.Get(configKeyURL))
	return strings.TrimRight(url, "/")
}

// SetURL sets the public master URL of the DC/OS cluster.
func (c *Config) SetURL(url string) {
	c.store.Set(configKeyURL, url)
}

// ACSToken returns the token generated by authenticating
// to DC/OS using the Admin Router Access Control Service.
func (c *Config) ACSToken() string {
	return cast.ToString(c.store.Get(configKeyACSToken))
}

// SetACSToken sets the token generated by authenticating
// to DC/OS using the Admin Router Access Control Service.
func (c *Config) SetACSToken(acsToken string) {
	c.store.Set(configKeyACSToken, acsToken)
}

// TLS returns the configuration for TLS clients.
func (c *Config) TLS() TLS {
	tlsVal := cast.ToString(c.store.Get(configKeyTLS))

	// Try to cast the value to a bool, true means we verify
	// server certificates, false means we skip verification.
	if verify, err := strconv.ParseBool(tlsVal); err == nil {
		return TLS{Insecure: !verify}
	}

	// The value is not a string representing a bool thus it is a path to a root CA bundle.
	rootCAsPEM, err := afero.ReadFile(c.store.Fs(), tlsVal)
	if err != nil {
		return TLS{
			Insecure:    true,
			RootCAsPath: tlsVal,
		}
	}

	// Decode the PEM root certificate(s) into a cert pool.
	certPool := x509.NewCertPool()
	if !certPool.AppendCertsFromPEM(rootCAsPEM) {
		return TLS{
			Insecure:    true,
			RootCAsPath: tlsVal,
		}
	}

	// The cert pool has been successfully created, store it in the TLS config.
	return TLS{
		RootCAs:     certPool,
		RootCAsPath: tlsVal,
	}
}

// SetTLS returns the configuration for TLS clients.
func (c *Config) SetTLS(tls TLS) {
	c.store.Set(configKeyTLS, tls.String())
}

// Timeout returns the HTTP request timeout once the connection is established.
func (c *Config) Timeout() time.Duration {
	timeout := c.store.Get(configKeyTimeout)
	return time.Duration(cast.ToInt64(timeout)) * time.Second
}

// SetTimeout sets the HTTP request timeout once the connection is established.
func (c *Config) SetTimeout(timeout time.Duration) {
	c.store.Set(configKeyTimeout, timeout.Seconds())
}

// ID returns the ID of the cluster.
func (c *Config) ID() string {
	if c.id != "" {
		return c.id
	}
	path := c.store.Path()
	return filepath.Base(filepath.Dir(path))
}

// SetID sets the ID of the cluster.
func (c *Config) SetID(id string) {
	c.id = id
}

// Name returns the name of the cluster.
func (c *Config) Name() string {
	return cast.ToString(c.store.Get(configKeyClusterName))
}

// SetName sets a name for the cluster.
func (c *Config) SetName(name string) {
	c.store.Set(configKeyClusterName, name)
}

// Store returns the config's store.
func (c *Config) Store() *ConfigStore {
	return c.store
}

// Dir returns the cluster's directory.
func (c *Config) Dir() string {
	return filepath.Dir(c.store.Path())
}

// TLS holds the configuration for TLS clients.
type TLS struct {
	// Insecure specifies if server certificates should be accepted without verification.
	//
	// Skipping verification against the system's CA bundle or a cluster-specific CA is highly discouraged
	// and should only be done during testing/development.
	Insecure bool

	// Path to the root CA bundle.
	RootCAsPath string

	// A pool of root CAs to verify server certificates against.
	RootCAs *x509.CertPool
}

// String creates a string from a TLS struct.
func (tls *TLS) String() string {
	if tls.RootCAsPath != "" {
		return tls.RootCAsPath
	}
	return strconv.FormatBool(!tls.Insecure)
}

// ConfigStoreOpts are functional options for a ConfigStore.
type ConfigStoreOpts struct {
	// EnvWhitelist is a map of config keys and environment variables.
	// When present, these env vars take precedence over the values in the toml.Tree.
	EnvWhitelist map[string]string

	// EnvLookup is the function used to lookup environment variables.
	// When not set it defaults to os.LookupEnv.
	EnvLookup func(key string) (string, bool)

	// Fs is an abstraction for the filesystem. All filesystem operations
	// for the store should be done through it instead of the os package.
	Fs afero.Fs
}

// ConfigStore is the backend for Config data. It aggregates multiple sources
// (env vars, TOML document) and is able to get/set/unset key(s) in the TOML document.
type ConfigStore struct {
	path         string
	tree         *toml.Tree
	envWhitelist map[string]string
	envLookup    func(key string) (string, bool)
	fs           afero.Fs
}

// NewConfigStore creates a ConfigStore based on functional options.
func NewConfigStore(opts *ConfigStoreOpts) *ConfigStore {
	if opts == nil {
		opts = &ConfigStoreOpts{}
	}

	if opts.EnvWhitelist == nil {
		opts.EnvWhitelist = map[string]string{
			configKeyTLS:     envTLS,
			configKeyTimeout: envTimeout,
		}
	}

	if opts.EnvLookup == nil {
		opts.EnvLookup = os.LookupEnv
	}

	if opts.Fs == nil {
		opts.Fs = afero.NewOsFs()
	}

	tree, _ := toml.TreeFromMap(make(map[string]interface{}))

	return &ConfigStore{
		tree:         tree,
		envWhitelist: opts.EnvWhitelist,
		envLookup:    opts.EnvLookup,
		fs:           opts.Fs,
	}
}

// LoadPath populates the store based on a path to a TOML file.
// If the file doesn't exist, an empty one is created.
func (c *ConfigStore) LoadPath(path string) error {
	f, err := c.fs.OpenFile(path, os.O_RDONLY|os.O_CREATE, 0600)
	if err != nil {
		return err
	}
	defer f.Close()

	if err := c.LoadReader(f); err != nil {
		return err
	}
	c.path = path
	return nil
}

// LoadReader populates the store based on an io.Reader containing TOML data.
func (c *ConfigStore) LoadReader(reader io.Reader) error {
	tree, err := toml.LoadReader(reader)
	if err != nil {
		return err
	}
	c.LoadTree(tree)
	return nil
}

// LoadTree populates the store with a TOML tree.
func (c *ConfigStore) LoadTree(tree *toml.Tree) {
	c.tree = tree
}

// Path returns the path to the Config.
func (c *ConfigStore) Path() string {
	return c.path
}

// SetPath assigns a path to the Config.
func (c *ConfigStore) SetPath(path string) {
	c.path = path
}

// Fs returns the filesystem for the store.
func (c *ConfigStore) Fs() afero.Fs {
	return c.fs
}

// Get returns a value from the Config using a key.
func (c *ConfigStore) Get(key string) interface{} {
	// Check if the given key is whitelisted as an env var.
	if envVar, ok := c.envWhitelist[key]; ok {
		// If so, look-it up.
		if envVal, ok := c.envLookup(envVar); ok {
			return envVal
		}
	}

	// Fallback to the TOML tree if present.
	switch node := c.tree.Get(key).(type) {
	case *toml.Tree, []*toml.Tree:
		return nil
	default:
		return node
	}
}

// Set sets a key in the store.
func (c *ConfigStore) Set(key string, val interface{}) (err error) {
	switch key {
	case configKeyURL:
		// Make sure the ACS token is unset whenever the DC/OS URL is updated.
		c.Unset(configKeyACSToken)
	case configKeyTimeout:
		// go-toml requires int64
		val, err = cast.ToInt64E(val)
	case configKeyTLS:
		if _, err = cast.ToBoolE(val); err != nil {
			_, err = c.fs.Stat(cast.ToString(val))
		}
	case configKeyPagination, configKeyReporting, configKeyPromptLogin:
		val, err = cast.ToBoolE(val)
	default:
		val, err = cast.ToStringE(val)
	}
	if err == nil {
		c.tree.Set(key, val)
	}
	return err
}

// Unset deletes a given key from the Config.
func (c *ConfigStore) Unset(key string) {
	if key == configKeyURL {
		// Unset the ACS token as well when removing the DC/OS URL.
		c.Unset(configKeyACSToken)
	}
	keys := strings.Split(key, ".")

	treeMap := c.tree.ToMap()
	subMap := treeMap

	// Extract a sub-map for each dotted key section.
	for i, key := range keys {
		if node, ok := subMap[key]; ok {
			switch nodeType := node.(type) {
			case map[string]interface{}:
				subMap = nodeType
			default:
				// Abort if the section is not a map, unless it's the last section.
				if i == len(keys)-1 {
					// Remove the key from the parent map and swap trees.
					delete(subMap, key)
					c.tree, _ = toml.TreeFromMap(treeMap)
				} else {
					return
				}
			}
		}
	}
}

// Persist flushes the in-memory TOML tree representation to the path associated to the Config.
func (c *ConfigStore) Persist() error {
	if c.path == "" {
		return ErrNoConfigPath
	}
	var buf bytes.Buffer
	if _, err := c.tree.WriteTo(&buf); err != nil {
		return err
	}
	return afero.WriteFile(c.fs, c.path, buf.Bytes(), 0600)
}

// Keys returns all the keys in the Config.
func (c *ConfigStore) Keys() []string {
	var keys []string
	for key, envVar := range c.envWhitelist {
		if _, ok := c.envLookup(envVar); ok {
			keys = append(keys, key)
		}
	}

	c.searchKeys(c.tree, &keys, []string{})
	keysLen := len(keys)
	if keysLen < 2 {
		// Less than 2 keys, no need to sort or remove duplicates.
		return keys
	}

	sort.Strings(keys)

	// Remove duplicates, this happens when there is both an env var and a TOML key.
	// Keys are already sorted so this is done by comparing each key with the next one
	// and removing the latter if it's the same.
	for i := 1; i < keysLen; i++ {
		if keys[i] == keys[i-1] {
			keys = append(keys[:i], keys[i+1:]...)
			keysLen--
		}
	}
	return keys
}

// searchKeys walks recursively through a toml.Tree and appends the full path to each leaf into keys.
func (c *ConfigStore) searchKeys(tree *toml.Tree, keys *[]string, keyPath []string) {
	for _, key := range tree.Keys() {
		childKeyPath := append(keyPath, key)
		switch node := tree.Get(key).(type) {
		case *toml.Tree:
			c.searchKeys(node, keys, childKeyPath)
		default:
			*keys = append(*keys, strings.Join(childKeyPath, "."))
		}
	}
}

// ConfigManagerOpt are functional options for a Manager.
type ConfigManagerOpt func(*ConfigManager)

// ConfigFSOpt returns a ConfigManagerOpt that sets an abstraction for the filesystem for the config manager.
// All filesystem operations for the manager should be done through it instead of the os package.
func ConfigFSOpt(fs afero.Fs) ConfigManagerOpt {
	return func(cm *ConfigManager) {
		cm.fs = fs
	}
}

// EnvLookup is the function used to lookup environment variables.
// When not set it defaults to os.LookupEnv.
type EnvLookup func(key string) (string, bool)

// ConfigEnvLookupOpt returns a ConfigManagerOpt that sets the env lookup func for the config manager.
func ConfigEnvLookupOpt(f EnvLookup) ConfigManagerOpt {
	if f == nil {
		return nil
	}
	return func(cm *ConfigManager) {
		cm.envLookup = f
	}
}

// ConfigDirOpt returns a ConfigManagerOpt that sets the root directory for the config manager.
func ConfigDirOpt(dir string) ConfigManagerOpt {
	return func(cm *ConfigManager) {
		cm.dir = dir
	}
}

func expandHomeDir() string {
	dir, err := homedir.Expand(dcosDefaultFolder)
	if err != nil {
		return dcosDefaultFolder
	}
	return dir
}

// ConfigManager is able to retrieve, create, and delete configs.
type ConfigManager struct {
	fs        afero.Fs
	envLookup func(key string) (string, bool)
	dir       string
}

// NewConfigManager creates a new config manager.
func NewConfigManager(opts ...ConfigManagerOpt) *ConfigManager {
	configManager := &ConfigManager{
		fs:        afero.NewOsFs(),
		envLookup: os.LookupEnv,
		dir:       expandHomeDir(),
	}

	for _, opt := range opts {
		if opt != nil {
			opt(configManager)
		}
	}

	return configManager
}

// Current retrieves the current config.
//
// The lookup order is :
// - DCOS_CLUSTER is defined and is the name/ID of a configured cluster.
// - An attached file exists alongside a configured cluster, OR there is a single configured cluster.
func (m *ConfigManager) Current() (*Config, error) {
	if configName, ok := m.envLookup("DCOS_CLUSTER"); ok {
		return m.Find(configName, true)
	}

	configs := m.All()
	if len(configs) == 1 {
		return configs[0], nil
	}

	var currentConfig *Config
	for _, config := range configs {
		attachedFile := m.attachedFilePath(config)
		if m.fileExists(attachedFile) {
			if currentConfig != nil {
				return nil, errors.New("multiple clusters are attached")
			}
			currentConfig = config
		}
	}
	if currentConfig == nil {
		return nil, ErrNotAttached
	}
	return currentConfig, nil
}

// Find finds a config by cluster name or ID, `strict` indicates
// whether or not the search string can also be a cluster ID prefix.
func (m *ConfigManager) Find(name string, strict bool) (*Config, error) {
	var matches []*Config
	for _, config := range m.All() {
		if name == config.Name() {
			matches = append(matches, config)
		}
		clusterID := filepath.Base(filepath.Dir(config.store.Path()))
		if clusterID == name {
			return config, nil
		}
		if !strict && strings.HasPrefix(clusterID, name) {
			matches = append(matches, config)
		}
	}

	switch len(matches) {
	case 0:
		return nil, ErrConfigNotFound
	case 1:
		return matches[0], nil
	default:
		return nil, ErrTooManyConfigs
	}
}

// All retrieves all configs.
func (m *ConfigManager) All() (configs []*Config) {
	configsDir, err := m.fs.Open(filepath.Join(m.dir, "clusters"))
	if err != nil {
		return
	}
	defer configsDir.Close()

	configsDirInfo, err := configsDir.Readdir(-1)
	if err != nil {
		return
	}

	for _, configDirInfo := range configsDirInfo {
		if configDirInfo.IsDir() {
			config := m.newConfig()
			configPath := filepath.Join(configsDir.Name(), configDirInfo.Name(), "dcos.toml")
			if err := config.store.LoadPath(configPath); err == nil {
				configs = append(configs, config)
			}
		}
	}

	return
}

// Save saves a config to the disk under the given cluster ID folder.
func (m *ConfigManager) Save(config *Config, id string, caBundle []byte) error {
	configDir := filepath.Join(m.dir, "clusters", id)
	if err := m.fs.MkdirAll(configDir, 0755); err != nil {
		return err
	}
	if len(caBundle) > 0 {
		caBundlePath := filepath.Join(configDir, "dcos_ca.crt")
		err := afero.WriteFile(m.fs, caBundlePath, caBundle, 0644)
		if err != nil {
			return err
		}
		config.store.Set(configKeyTLS, caBundlePath)
	}
	config.store.SetPath(filepath.Join(configDir, "dcos.toml"))
	return config.store.Persist()
}

// Attach sets a given config as the current one. This is done by adding an `attached`
// file next to it. If another config is already attached, the file gets moved.
func (m *ConfigManager) Attach(config *Config) error {
	var currentAttachedFile string

	// Iterate over all configs to find the one with an attached file, if any.
	for _, c := range m.All() {
		attachedFile := m.attachedFilePath(c)
		if m.fileExists(attachedFile) {
			currentAttachedFile = attachedFile
			break
		}
	}

	configAttachedPath := m.attachedFilePath(config)

	// Create the attached file if no config is currently attached, otherwise move it.
	if currentAttachedFile == "" {
		f, err := m.fs.Create(configAttachedPath)
		if err != nil {
			return err
		}
		return f.Close()
	}
	return m.fs.Rename(currentAttachedFile, configAttachedPath)
}

// attachedFilePath returns the `attached` file path for a given config.
func (m *ConfigManager) attachedFilePath(conf *Config) string {
	return filepath.Join(filepath.Dir(conf.store.Path()), "attached")
}

// fileExists returns whether or not a file exists.
func (m *ConfigManager) fileExists(path string) bool {
	fileInfo, err := m.fs.Stat(path)
	if err != nil {
		return false
	}
	return fileInfo.Mode().IsRegular()
}

func (m *ConfigManager) newConfig() *Config {
	return NewConfig(NewConfigStore(&ConfigStoreOpts{
		EnvLookup: m.envLookup,
		Fs:        m.fs,
	}))
}
